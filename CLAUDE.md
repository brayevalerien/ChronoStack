Create a new Python project called chronostack that implements a stack-based programming language with time travel mechanics. The language should have a timeline of stack states where each operation creates a new moment in time and programs can jump between moments, peek into future states, and modify the past with ripple effects.

Implement a lexer that tokenizes the following: numbers (integers), strings (double-quoted), symbols (colon followed by identifier), operators (push pop dup swap rot tick rewind peek-future branch merge paradox! echo send temporal-fold ripple + - * / % < > = and or not if loop when-stable), brackets for code blocks, and semicolon for definition end. Handle whitespace and comments starting with #.

Implement a parser that builds an abstract syntax tree from tokens. The parser should handle literals, operations, code blocks enclosed in brackets, and word definitions using :name ... ; syntax. Code blocks should be treated as quoted lists that can be pushed onto the stack.

Create a Timeline class that manages multiple moments where each moment contains a stack state and metadata. Implement methods for advancing time (creating new moments), rewinding to previous moments, branching to create alternate timelines, merging timelines, and detecting/resolving paradoxes. Each moment should store its stack as a list, a parent moment reference, branch information, and a timestamp index.

Create an Interpreter class that executes the parsed AST. Maintain a current timeline, current moment index, and defined words dictionary. Implement all stack operations: push (add value to stack), pop (remove and return top), dup (duplicate top), swap (exchange top two), rot (rotate top three items). Implement temporal operations: tick (save current stack and advance to new moment), rewind n (go back n moments), peek-future n (look ahead n moments creating branches if needed), branch (create alternate timeline), merge (combine current timeline with parent), paradox! (resolve paradoxes by selecting most stable timeline), echo n (copy value from n moments ago), send n (send current top value n moments into the past creating a causal loop), temporal-fold (apply operation across all moments), ripple (apply operation to all future moments).

Implement math operations (+ - * / %) that pop two values and push result. Implement comparison operations (< > =) that push 1 for true or 0 for false. Implement logical operations (and or not). Implement control flow: if (pop condition and code block, execute block if condition is truthy), loop (pop count and code block, execute block n times), when-stable (execute block only if timeline has no paradoxes). Implement word definition where :name starts capturing tokens until ; is reached, storing the tokens as a reusable word.

For paradox resolution, detect when a value sent to the past would change the computation that led to sending that value. Implement a stability check that tries different resolution strategies: keep original timeline, accept the change and recalculate, or find a fixed point where the sent value equals what would be computed. Choose the resolution that creates the most consistent timeline.

Implement timeline branching where branch creates a new timeline that shares history up to the current moment but diverges afterward. peek-future should create a speculative branch if the future doesn't exist yet. merge should integrate changes from a branch back into its parent timeline, resolving conflicts by preferring the branch's values.

Create a REPL (read-eval-print loop) that accepts ChronoStack code, executes it, and displays the current stack state and moment index. Add debugging commands: .timeline to show all moments and their stacks, .branches to show timeline structure, .stack to show current stack, .moment to show current moment index, .words to list defined words, and .help for command list.
`
Add visualization features that show the timeline as an ASCII tree with branches, display stack states at each moment, and highlight paradoxes and their resolutions. Include example programs: fibonacci using echo to access previous values, a palindrome checker using temporal-fold, a self-fulfilling prophecy using peek-future, a quantum coin flip simulation using branches, and a paradox example using send.

Handle edge cases: empty stack operations should error gracefully, rewinding before moment 0 should stop at 0, peek-future beyond existing moments should create speculative branches, circular paradoxes should timeout and pick a default resolution, and infinite loops in temporal operations should be detected.

Create a main.py file that provides both a REPL mode and file execution mode. Support command line arguments for input files, debugging flags, and timeline visualization options. Include comprehensive error messages that show the current moment, stack state, and timeline structure when errors occur.

Write unit tests for the lexer, parser, timeline operations, interpreter operations, and paradox resolution. Include integration tests for complete example programs. Test edge cases like empty stacks, timeline boundaries, and paradox creation.

The implementation should be in Python 3.8+ using only standard library modules. Focus on clarity and correctness over performance. Make the codebase modular with separate files for lexer, parser, timeline, interpreter, and REPL. Include docstrings and comments explaining the temporal mechanics. The goal is to create a working interpreter that makes temporal stack manipulation fun and mind-bending while remaining mathematically consistent and Turing complete.