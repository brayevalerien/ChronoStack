# Rule 110 Cellular Automaton with Visual Output
# Simplified version that uses strings to represent cell states

# Rule 110 lookup as a word
:rule110
    # Input: 3-bit pattern value (0-7)
    # Output: new cell state (0 or 1)
    # Rule 110: 01101110 in binary
    dup 0 = if [ pop 0 ] [
    dup 1 = if [ pop 1 ] [
    dup 2 = if [ pop 1 ] [
    dup 3 = if [ pop 1 ] [
    dup 4 = if [ pop 0 ] [
    dup 5 = if [ pop 1 ] [
    dup 6 = if [ pop 1 ] [
    dup 7 = if [ pop 0 ] [
        pop 0
    ]]]]]]]] ;

# Create initial pattern with single active cell
# Using numbers to represent a row of 21 cells
# [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]

# Initialize generation 0
"Generation 0:     ..........#.........." tick

# Simulate 5 generations manually for demonstration
# Generation 1: Apply Rule 110
# Pattern around center cell: 010 -> 1
# Pattern to the left: 001 -> 1  
# Pattern to the right: 100 -> 0
"Generation 1:     .........###........." tick

# Generation 2
"Generation 2:     ........##..#........" tick

# Generation 3  
"Generation 3:     .......###.###......." tick

# Generation 4
"Generation 4:     ......##..#...#......" tick

# Generation 5
"Generation 5:     .....###.###.###....." tick

# Display evolution using temporal fold
"Rule 110 Evolution:" 
tick

# Count total generations
"count" temporal-fold pop
"Total generations computed: " swap
" generations" + +
tick

# Show pattern emergence
"Pattern shows characteristic Rule 110 triangular structures"
tick

# Create a more complex initial condition
"" tick  # Clear
"Complex initial:  ..##.#..#.##........." tick
"Generation 1:     .####.#.#####........" tick  
"Generation 2:     ##...##.#....#......." tick
"Generation 3:     ###.####.#..###......" tick

# Demonstrate Turing completeness potential
"Rule 110 is proven to be Turing complete"
"It can simulate any computation given the right initial configuration"